---
title: "Data Transformations"
author: "Daniel Woodie"
date: "6/19/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

# Workshop Overview

  -  The pipe: `%>%` (Ceci n'est pas une pipe)
  - Selecting: `select()`
  - Filtering: `filter()`
  - Creating Columns: `mutate()`
  - Aggregating: `group_by()`
  - Aggregate summary: `summarise()`

## Tidy Data

## The Pipe

The pipe is fundamental a tidy data workflow. As a bit of background, the pipe was first implemented in Hadley Wickham's package `magrittr`. The package's sole purpose was to introduce the pipe operator to chain commands together. The pipe (`%>%`) sends a value forward into a function call.

The name `magrittr` comes from the famous surrealist painting from **Rene Magritte** as seen below.

<!-- <img src="https://upload.wikimedia.org/wikipedia/en/thumb/b/b9/MagrittePipe.jpg/300px-MagrittePipe.jpg" width=100%/> -->

<!-- Hadley's cleverness is embodied by the below picture. -->
<!-- <img src="https://itsalocke.com/wp-content/uploads/2015/04/magrittr_m6tn2w.jpg" width=100% /> -->


The pipe (`%>%`) makes the value that you *piped forward* the first argument within a function call. If the piped value isn't the first argument, you can use `.` to represent those data (this is a lot easier than typing the same value name over and over).

- the pipe works with the functions in dplyr because the first argument is almost always the data source

Before we get into the `dplyr` verbs, let's use some functions that we should all be somewhat familiar with and usually only take 1 argument:

  - `head()`
  - `dim()`
  - `str()`
  - `summary()`

Let's explore the pipe with some data about major battles in A Song of Ice and Fire (Game of Thrones). Thank you to [@Chrisalbon]("https://github.com/chrisalbon/war_of_the_five_kings_dataset") for making the data set.


First, read the data to make it available:

```{r, message=FALSE, warning=FALSE}
# Read the data
GOT <- readr::read_csv("data/GoT_demo_dat.csv")
```

Try all of the functions as you normally would:
```{r, eval=FALSE}
head(GOT)
dim(GOT)
str(GOT)
summary(GOT)
```

Try the functions using the pipe:

```{r, eval=FALSE}
GOT %>% head() # preview the data frame (tibble)

GOT %>% dim() # gets the dimensions (rows and colums)

GOT %>% str() # gets the dataframe structure

GOT %>% summary() # creates column and data frame summary
```

This data set has been modified from it's original size and shape to be a bit more friendly. There are 6 columns:

  - `name`: name of the battle
  - `attacker_outcome`: Whether the battle was won or lost by the attacker
  - `attacker_king`: Which King initiated the attack
  - `defender_king`: Which king had to defend
  - `attacker_size`: Number of people in battle for attacker
  - `defender_size`: Number of people in battle for defender

### Review

* The pipe sends values forward as the first function argument.
* Values that have been piped can be accessed by using `.`

Now that we have a sense of how the pipe works. We can explore some of the famous `dplyr` verbs.

## Select

Often times you will have more columns than you're actually interested in. With the `select()` function it is possible to return a data frame which contains only columns that are specified. Select can also be used to rearrange column order.

### Exploring Basic Functionality

- select specific columns
- reorder columns

#### Example:

Select the battle name, battle outcome, and the attacking king. These are variables `name`, `attacker_outcome`, `attacker_king`, repsectively. 

Notice how if you change the order of the select statement it changes the order of the columns.

```{r}
GOT %>% 
  select(name, attacker_king, defender_king)

GOT %>%
  select(attacker_king, name, defender_king)
```
You can also use the `-` (subtraction operator) to select everything **but** the specified column.

```{r}
GOT %>%
  select(-defender_king)
```
Additionally, you can select a number columns positionally by using a colon `:`.

```{r}
GOT %>%
  select(attacker_king:attacker_size)
```

### `select()` helper verbs

`dplyr` also provides a number of helper verbs that aid in selecting columns. The helper functions we will explore are:

  - `starts_with()`
  - `ends_with()`
  - `everything()`
  
Often times column names will follow a pattern. Column names might have similar prefixes or suffixes. This Game of Thrones data set has a number of columns that start with *attacker* or *defender*, and two columns that end with *king*.

`dplyr`'s helper verbs can aid in selecting based on prefixes or suffixes using `starts_with()` and `ends_with()` respectively. The only argument you need to supply to these functions is a string to match (remeber that a string is any characters enclosed by quotes, eg. `"my string"`).

To see how this works, let's look at just those columns that start with `attacker`, and end with `king`.

```{r}
GOT %>%
  select(starts_with("attacker"))

GOT %>% 
  select(ends_with("king"))
```

Sometimes it is helpful to have select columns before others. `select()` can be used to specify column order, but if you wanted to keep all of the other columns and not specify every remaining one the verb `everything()` would select every remaining column.

**Example**:
Lets arrange the data frame to be ordered by the attacking king then every other column.

```{r}
GOT %>%
  select(attacker_king, everything())
```
### Putting it all together

Now lets try and combine all of the select function into one select statement. 

Say we want to have a data frame containing the battle name, all columns starting with `"attacker"`, and everything else except the defender king.

```{r}
GOT %>%
  select(name, starts_with("attacker"), everything(), -defender_king)
```

There are additional options that select columns based on a specific criteria including, but not limited to:

  - `contains()`: column name has a specified character string in it
  - `matches()`: uses a regex (regular expression) to match column names
  - `one_of()`: selects column names from a group of names


## Filtering

`filter()` is personally my favorite `dplyr` verb. It provides a very intuitive, and clean way of subsetting data. `filter()` is used to identify rows/observations/cases where supplied conditions are true. This should be familiar to those who are comfortable with querying using a `SQL` `where` clause.

Before we can get into filtering, we need to be comfortable with logical operators. The main operators you will use for `filter()` are:

  - `==` : equal to
  - `!=` : not equal to
  - `>` or `>=` : greater than *or* greater than or equal to
  - `<` or `<=` : less than *or* less than or equal to
  - `&` : and (vectorized)
  - `|` : or (vectorized)
  
### Checking equivalence

The operators `==` and `!=` are use to check for equivalence. I think of it as asking a question. For example I can write **"Is 1 equal to 1?"** as `1 == 1`. I know that 1 is actually equivalent to 1 and therefore expect the result to be `TRUE`. Conversely, since we can ask if **"is 1 *not* equal to 1?"** as `1 != 1`. We can expect the result to be no, or `FALSE`. 

Similarly we can check quantities using greater than or less than operators. 

- *Is 2 greater than 1?*
    - `2 > 1`: `TRUE`
- *Is 2 less than 1?*
    - `2 < 1`: `FALSE`
- *Is 2 greater than or equal to 2?*
    - `2 >= 2`: `TRUE`
- *Is 2 less than or equal to 1?*
    - `2 <= 1`: `FALSE`




## Mutate

## Group By

## Sum
marise

## dbplyr
